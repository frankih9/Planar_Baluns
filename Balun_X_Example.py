'''
This script is to call the appropriate functions to generate a balun with the 
'X' structure only.  Also, this script assumes that the cells generated by the 
individual functions remain in memory so 'Balun_X_Build' function can reference
to them and use them to construct the balun.  Apparently this is how 'gdspy' works.
'''
import gdspy
import Balun_Scripts.Balun_Parts as BP
import Balun_Scripts.Valid_Check as VC
from Balun_Scripts.Balun_X_Build import Balun_X_Build

#define global library
lib = gdspy.GdsLibrary()

#########################
# Variables. Change me. #
#########################

# GDS cell name for the balun
Cell_Name = 'Balun_X'

# via row and columns
viaM = 4
# Square via width
viaW = 1
# via spacing 
viaS = 1

# Length of the balun
balunLength = 250
# Width of each track
trackWidth = 9
# Spacing between tracks
trackSpacing = 3

# Turns in the primary
primaryTurns = 2
# Turns in the secondary
secondaryTurns = 3

##########################################
# Generate GDS cells of some balun parts #
##########################################
# Order is important as certain functions depend on previously generated GDS cells.

# Generate GDS cell for a square
BP.SQ(lib, trackWidth)

# Generate GDS cell for the via array
BP.VIA(lib, int(viaM), viaW, viaS)

# Generate the 'X' crossover
BP.X(lib, trackWidth, trackSpacing)

#############################################################
# With the given balun parameters, will the balun be valid? #
#############################################################
# Total number of tracks is primary turns plus secondary turns
max_tracks = VC.max_tracks(lib, balunLength, trackWidth, trackSpacing, 'X')

# There should not be zero turns anywhere 
ratio_valid = VC.Ratio_X(int(primaryTurns), int(secondaryTurns))

if max_tracks >= (int(primaryTurns) + int(secondaryTurns)) and ratio_valid:
    
    ###############################################
    # Generate GDS cells of remaining balun parts #
    ###############################################
    # Generate the all the tracks
    BP.TR(lib, balunLength, trackWidth, trackSpacing, int(primaryTurns), int(secondaryTurns))

    # Generate ports
    BP.P(lib, 'X')
    
    ################################
    # Construct the 'X' type balun #
    ################################
    Balun_X_Build(lib, balunLength, trackWidth, trackSpacing, int(primaryTurns), int(secondaryTurns), C_Name = Cell_Name)
    
    #####################################################
    # Only write the balun cell into the GDS file in um #
    #####################################################
    cell_list = []
    cell_list.append(Cell_Name)
    gdspy.write_gds(Cell_Name + '.gds', cells = cell_list, unit = 1.0e-6, precision = 1.0e-9)
    
    ################################################
    # Display all the GDS cells in current library #
    ################################################
    gdspy.LayoutViewer(lib)
    
else:
    ##############################
    # Display issues with inputs #
    ##############################
    if max_tracks < (int(primaryTurns) + int(secondaryTurns)):
        print('Maximum number of tracks is: '+str(max_tracks))
        
    if ratio_valid == False:
        print('Turn ratio not valid!')