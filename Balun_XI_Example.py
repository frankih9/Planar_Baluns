'''
This script is to call the appropriate functions to generate baluns with the 
'XI' structure.  Also, this script assumes that the cells generated by the 
individual functions remain in memory so 'Balun_XI_Build' function can reference
to them and use them to construct the balun.
'Balun_XI_Build' supports Pri:Sec turn ratios where Pri is an integer >= 1 and 
Sec is an even integer >= 2.  However, for non 1:2 baluns, the turns are expanded
from the maximum 1:2 ratio. 

Examples: 
(1) 6:6 => 3:6 with 3 turns expanded in the primary
(2) 2:6 => 2:4 with 2 turns expanded in the secondary
(3) 2:7 => not allowed because Sec is odd
(4) 4:2 => 1:2 with 3 turns expanded in the primary
'''

import gdspy
import Balun_Scripts.Balun_Parts as BP
import Balun_Scripts.Valid_Check as VC
from Balun_Scripts.Balun_XI_Build import Balun_XI_Build

#define global library
lib = gdspy.GdsLibrary()

#########################
# Variables. Change me. #
#########################

# GDS cell name for the balun
Cell_Name = 'Balun_XI'

# via row and columns
viaM = 4
# Square via width
viaW = 1
# via spacing 
viaS = 1

# Length of the balun
balunLength = 250
# Width of each track
trackWidth = 8
# Spacing between tracks
trackSpacing = 3

# Turns in the primary
primaryTurns = 3
# Turns in the secondary
secondaryTurns = 2

##########################################
# Generate GDS cells of some balun parts #
##########################################
# Order is important as certain functions depend on previously generated GDS cells.

# Generate GDS cell for a square
BP.SQ(lib, trackWidth)

# Generate GDS cell for the via array
BP.VIA(lib, int(viaM), viaW, viaS)

# Generate the 'XX' crossover
BP.XX(lib, trackWidth, trackSpacing)

# Generate the 'XI' crossover
BP.XI(lib, trackWidth, trackSpacing)

# Generate the 'X' crossover
BP.X(lib, trackWidth, trackSpacing)

#############################################################
# With the given balun parameters, will the balun be valid? #
#############################################################
# Total number of tracks is primary turns plus secondary turns
max_tracks = VC.max_tracks(lib, balunLength, trackWidth, trackSpacing, 'XI')

# There should not be zero turns anywhere and secondary should be even
ratio_valid = VC.Ratio_XI(int(primaryTurns), int(secondaryTurns))

if max_tracks >= (int(primaryTurns) + int(secondaryTurns)) and ratio_valid:
    
    ###############################################
    # Generate GDS cells of remaining balun parts #
    ###############################################
    # Generate the all the tracks
    BP.TR(lib, balunLength, trackWidth, trackSpacing, int(primaryTurns), int(secondaryTurns))

    # Generate ports
    BP.P(lib)

    #################################
    # Construct the 'XI' type balun #
    #################################
    Balun_XI_Build(lib, balunLength, trackWidth, trackSpacing, int(primaryTurns), int(secondaryTurns), C_Name = Cell_Name)
    
    #####################################################
    # Only write the balun cell into the GDS file in um #
    #####################################################
    cell_list = []
    cell_list.append(Cell_Name)
    gdspy.write_gds(Cell_Name + '.gds', cells = cell_list, unit = 1.0e-6, precision = 1.0e-9)
    
    ################################################
    # Display all the GDS cells in current library #
    ################################################
    gdspy.LayoutViewer(lib)
    
else:
    ##############################
    # Display issues with inputs #
    ##############################
    if max_tracks < (int(primaryTurns) + int(secondaryTurns)):
        print('Maximum number of tracks is: '+str(max_tracks))
        
    if ratio_valid == False:
        print('Turn ratio not valid!')